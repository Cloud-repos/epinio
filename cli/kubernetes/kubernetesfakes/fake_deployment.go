// Code generated by counterfeiter. DO NOT EDIT.
package kubernetesfakes

import (
	"sync"

	"github.com/suse/carrier/cli/kubernetes"
)

type FakeDeployment struct {
	BackupStub        func(kubernetes.Cluster, string) error
	backupMutex       sync.RWMutex
	backupArgsForCall []struct {
		arg1 kubernetes.Cluster
		arg2 string
	}
	backupReturns struct {
		result1 error
	}
	backupReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(kubernetes.Cluster) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 kubernetes.Cluster
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeployStub        func(kubernetes.Cluster) error
	deployMutex       sync.RWMutex
	deployArgsForCall []struct {
		arg1 kubernetes.Cluster
	}
	deployReturns struct {
		result1 error
	}
	deployReturnsOnCall map[int]struct {
		result1 error
	}
	DescribeStub        func() string
	describeMutex       sync.RWMutex
	describeArgsForCall []struct {
	}
	describeReturns struct {
		result1 string
	}
	describeReturnsOnCall map[int]struct {
		result1 string
	}
	GetDomainStub        func() string
	getDomainMutex       sync.RWMutex
	getDomainArgsForCall []struct {
	}
	getDomainReturns struct {
		result1 string
	}
	getDomainReturnsOnCall map[int]struct {
		result1 string
	}
	GetVersionStub        func() string
	getVersionMutex       sync.RWMutex
	getVersionArgsForCall []struct {
	}
	getVersionReturns struct {
		result1 string
	}
	getVersionReturnsOnCall map[int]struct {
		result1 string
	}
	IDStub        func() kubernetes.DeploymentID
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 kubernetes.DeploymentID
	}
	iDReturnsOnCall map[int]struct {
		result1 kubernetes.DeploymentID
	}
	NeededUserInputStub        func() kubernetes.InstallationOptions
	neededUserInputMutex       sync.RWMutex
	neededUserInputArgsForCall []struct {
	}
	neededUserInputReturns struct {
		result1 kubernetes.InstallationOptions
	}
	neededUserInputReturnsOnCall map[int]struct {
		result1 kubernetes.InstallationOptions
	}
	RestoreStub        func(kubernetes.Cluster, string) error
	restoreMutex       sync.RWMutex
	restoreArgsForCall []struct {
		arg1 kubernetes.Cluster
		arg2 string
	}
	restoreReturns struct {
		result1 error
	}
	restoreReturnsOnCall map[int]struct {
		result1 error
	}
	SetDomainStub        func(string)
	setDomainMutex       sync.RWMutex
	setDomainArgsForCall []struct {
		arg1 string
	}
	UpgradeStub        func(kubernetes.Cluster) error
	upgradeMutex       sync.RWMutex
	upgradeArgsForCall []struct {
		arg1 kubernetes.Cluster
	}
	upgradeReturns struct {
		result1 error
	}
	upgradeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDeployment) Backup(arg1 kubernetes.Cluster, arg2 string) error {
	fake.backupMutex.Lock()
	ret, specificReturn := fake.backupReturnsOnCall[len(fake.backupArgsForCall)]
	fake.backupArgsForCall = append(fake.backupArgsForCall, struct {
		arg1 kubernetes.Cluster
		arg2 string
	}{arg1, arg2})
	stub := fake.BackupStub
	fakeReturns := fake.backupReturns
	fake.recordInvocation("Backup", []interface{}{arg1, arg2})
	fake.backupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) BackupCallCount() int {
	fake.backupMutex.RLock()
	defer fake.backupMutex.RUnlock()
	return len(fake.backupArgsForCall)
}

func (fake *FakeDeployment) BackupCalls(stub func(kubernetes.Cluster, string) error) {
	fake.backupMutex.Lock()
	defer fake.backupMutex.Unlock()
	fake.BackupStub = stub
}

func (fake *FakeDeployment) BackupArgsForCall(i int) (kubernetes.Cluster, string) {
	fake.backupMutex.RLock()
	defer fake.backupMutex.RUnlock()
	argsForCall := fake.backupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeployment) BackupReturns(result1 error) {
	fake.backupMutex.Lock()
	defer fake.backupMutex.Unlock()
	fake.BackupStub = nil
	fake.backupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) BackupReturnsOnCall(i int, result1 error) {
	fake.backupMutex.Lock()
	defer fake.backupMutex.Unlock()
	fake.BackupStub = nil
	if fake.backupReturnsOnCall == nil {
		fake.backupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.backupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Delete(arg1 kubernetes.Cluster) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 kubernetes.Cluster
	}{arg1})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeDeployment) DeleteCalls(stub func(kubernetes.Cluster) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeDeployment) DeleteArgsForCall(i int) kubernetes.Cluster {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDeployment) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Deploy(arg1 kubernetes.Cluster) error {
	fake.deployMutex.Lock()
	ret, specificReturn := fake.deployReturnsOnCall[len(fake.deployArgsForCall)]
	fake.deployArgsForCall = append(fake.deployArgsForCall, struct {
		arg1 kubernetes.Cluster
	}{arg1})
	stub := fake.DeployStub
	fakeReturns := fake.deployReturns
	fake.recordInvocation("Deploy", []interface{}{arg1})
	fake.deployMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) DeployCallCount() int {
	fake.deployMutex.RLock()
	defer fake.deployMutex.RUnlock()
	return len(fake.deployArgsForCall)
}

func (fake *FakeDeployment) DeployCalls(stub func(kubernetes.Cluster) error) {
	fake.deployMutex.Lock()
	defer fake.deployMutex.Unlock()
	fake.DeployStub = stub
}

func (fake *FakeDeployment) DeployArgsForCall(i int) kubernetes.Cluster {
	fake.deployMutex.RLock()
	defer fake.deployMutex.RUnlock()
	argsForCall := fake.deployArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDeployment) DeployReturns(result1 error) {
	fake.deployMutex.Lock()
	defer fake.deployMutex.Unlock()
	fake.DeployStub = nil
	fake.deployReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeployReturnsOnCall(i int, result1 error) {
	fake.deployMutex.Lock()
	defer fake.deployMutex.Unlock()
	fake.DeployStub = nil
	if fake.deployReturnsOnCall == nil {
		fake.deployReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deployReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Describe() string {
	fake.describeMutex.Lock()
	ret, specificReturn := fake.describeReturnsOnCall[len(fake.describeArgsForCall)]
	fake.describeArgsForCall = append(fake.describeArgsForCall, struct {
	}{})
	stub := fake.DescribeStub
	fakeReturns := fake.describeReturns
	fake.recordInvocation("Describe", []interface{}{})
	fake.describeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) DescribeCallCount() int {
	fake.describeMutex.RLock()
	defer fake.describeMutex.RUnlock()
	return len(fake.describeArgsForCall)
}

func (fake *FakeDeployment) DescribeCalls(stub func() string) {
	fake.describeMutex.Lock()
	defer fake.describeMutex.Unlock()
	fake.DescribeStub = stub
}

func (fake *FakeDeployment) DescribeReturns(result1 string) {
	fake.describeMutex.Lock()
	defer fake.describeMutex.Unlock()
	fake.DescribeStub = nil
	fake.describeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeDeployment) DescribeReturnsOnCall(i int, result1 string) {
	fake.describeMutex.Lock()
	defer fake.describeMutex.Unlock()
	fake.DescribeStub = nil
	if fake.describeReturnsOnCall == nil {
		fake.describeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.describeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeDeployment) GetDomain() string {
	fake.getDomainMutex.Lock()
	ret, specificReturn := fake.getDomainReturnsOnCall[len(fake.getDomainArgsForCall)]
	fake.getDomainArgsForCall = append(fake.getDomainArgsForCall, struct {
	}{})
	stub := fake.GetDomainStub
	fakeReturns := fake.getDomainReturns
	fake.recordInvocation("GetDomain", []interface{}{})
	fake.getDomainMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) GetDomainCallCount() int {
	fake.getDomainMutex.RLock()
	defer fake.getDomainMutex.RUnlock()
	return len(fake.getDomainArgsForCall)
}

func (fake *FakeDeployment) GetDomainCalls(stub func() string) {
	fake.getDomainMutex.Lock()
	defer fake.getDomainMutex.Unlock()
	fake.GetDomainStub = stub
}

func (fake *FakeDeployment) GetDomainReturns(result1 string) {
	fake.getDomainMutex.Lock()
	defer fake.getDomainMutex.Unlock()
	fake.GetDomainStub = nil
	fake.getDomainReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeDeployment) GetDomainReturnsOnCall(i int, result1 string) {
	fake.getDomainMutex.Lock()
	defer fake.getDomainMutex.Unlock()
	fake.GetDomainStub = nil
	if fake.getDomainReturnsOnCall == nil {
		fake.getDomainReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getDomainReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeDeployment) GetVersion() string {
	fake.getVersionMutex.Lock()
	ret, specificReturn := fake.getVersionReturnsOnCall[len(fake.getVersionArgsForCall)]
	fake.getVersionArgsForCall = append(fake.getVersionArgsForCall, struct {
	}{})
	stub := fake.GetVersionStub
	fakeReturns := fake.getVersionReturns
	fake.recordInvocation("GetVersion", []interface{}{})
	fake.getVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) GetVersionCallCount() int {
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	return len(fake.getVersionArgsForCall)
}

func (fake *FakeDeployment) GetVersionCalls(stub func() string) {
	fake.getVersionMutex.Lock()
	defer fake.getVersionMutex.Unlock()
	fake.GetVersionStub = stub
}

func (fake *FakeDeployment) GetVersionReturns(result1 string) {
	fake.getVersionMutex.Lock()
	defer fake.getVersionMutex.Unlock()
	fake.GetVersionStub = nil
	fake.getVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeDeployment) GetVersionReturnsOnCall(i int, result1 string) {
	fake.getVersionMutex.Lock()
	defer fake.getVersionMutex.Unlock()
	fake.GetVersionStub = nil
	if fake.getVersionReturnsOnCall == nil {
		fake.getVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeDeployment) ID() kubernetes.DeploymentID {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeDeployment) IDCalls(stub func() kubernetes.DeploymentID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeDeployment) IDReturns(result1 kubernetes.DeploymentID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 kubernetes.DeploymentID
	}{result1}
}

func (fake *FakeDeployment) IDReturnsOnCall(i int, result1 kubernetes.DeploymentID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 kubernetes.DeploymentID
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 kubernetes.DeploymentID
	}{result1}
}

func (fake *FakeDeployment) NeededUserInput() kubernetes.InstallationOptions {
	fake.neededUserInputMutex.Lock()
	ret, specificReturn := fake.neededUserInputReturnsOnCall[len(fake.neededUserInputArgsForCall)]
	fake.neededUserInputArgsForCall = append(fake.neededUserInputArgsForCall, struct {
	}{})
	stub := fake.NeededUserInputStub
	fakeReturns := fake.neededUserInputReturns
	fake.recordInvocation("NeededUserInput", []interface{}{})
	fake.neededUserInputMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) NeededUserInputCallCount() int {
	fake.neededUserInputMutex.RLock()
	defer fake.neededUserInputMutex.RUnlock()
	return len(fake.neededUserInputArgsForCall)
}

func (fake *FakeDeployment) NeededUserInputCalls(stub func() kubernetes.InstallationOptions) {
	fake.neededUserInputMutex.Lock()
	defer fake.neededUserInputMutex.Unlock()
	fake.NeededUserInputStub = stub
}

func (fake *FakeDeployment) NeededUserInputReturns(result1 kubernetes.InstallationOptions) {
	fake.neededUserInputMutex.Lock()
	defer fake.neededUserInputMutex.Unlock()
	fake.NeededUserInputStub = nil
	fake.neededUserInputReturns = struct {
		result1 kubernetes.InstallationOptions
	}{result1}
}

func (fake *FakeDeployment) NeededUserInputReturnsOnCall(i int, result1 kubernetes.InstallationOptions) {
	fake.neededUserInputMutex.Lock()
	defer fake.neededUserInputMutex.Unlock()
	fake.NeededUserInputStub = nil
	if fake.neededUserInputReturnsOnCall == nil {
		fake.neededUserInputReturnsOnCall = make(map[int]struct {
			result1 kubernetes.InstallationOptions
		})
	}
	fake.neededUserInputReturnsOnCall[i] = struct {
		result1 kubernetes.InstallationOptions
	}{result1}
}

func (fake *FakeDeployment) Restore(arg1 kubernetes.Cluster, arg2 string) error {
	fake.restoreMutex.Lock()
	ret, specificReturn := fake.restoreReturnsOnCall[len(fake.restoreArgsForCall)]
	fake.restoreArgsForCall = append(fake.restoreArgsForCall, struct {
		arg1 kubernetes.Cluster
		arg2 string
	}{arg1, arg2})
	stub := fake.RestoreStub
	fakeReturns := fake.restoreReturns
	fake.recordInvocation("Restore", []interface{}{arg1, arg2})
	fake.restoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) RestoreCallCount() int {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	return len(fake.restoreArgsForCall)
}

func (fake *FakeDeployment) RestoreCalls(stub func(kubernetes.Cluster, string) error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = stub
}

func (fake *FakeDeployment) RestoreArgsForCall(i int) (kubernetes.Cluster, string) {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	argsForCall := fake.restoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeployment) RestoreReturns(result1 error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = nil
	fake.restoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) RestoreReturnsOnCall(i int, result1 error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = nil
	if fake.restoreReturnsOnCall == nil {
		fake.restoreReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.restoreReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) SetDomain(arg1 string) {
	fake.setDomainMutex.Lock()
	fake.setDomainArgsForCall = append(fake.setDomainArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetDomainStub
	fake.recordInvocation("SetDomain", []interface{}{arg1})
	fake.setDomainMutex.Unlock()
	if stub != nil {
		fake.SetDomainStub(arg1)
	}
}

func (fake *FakeDeployment) SetDomainCallCount() int {
	fake.setDomainMutex.RLock()
	defer fake.setDomainMutex.RUnlock()
	return len(fake.setDomainArgsForCall)
}

func (fake *FakeDeployment) SetDomainCalls(stub func(string)) {
	fake.setDomainMutex.Lock()
	defer fake.setDomainMutex.Unlock()
	fake.SetDomainStub = stub
}

func (fake *FakeDeployment) SetDomainArgsForCall(i int) string {
	fake.setDomainMutex.RLock()
	defer fake.setDomainMutex.RUnlock()
	argsForCall := fake.setDomainArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDeployment) Upgrade(arg1 kubernetes.Cluster) error {
	fake.upgradeMutex.Lock()
	ret, specificReturn := fake.upgradeReturnsOnCall[len(fake.upgradeArgsForCall)]
	fake.upgradeArgsForCall = append(fake.upgradeArgsForCall, struct {
		arg1 kubernetes.Cluster
	}{arg1})
	stub := fake.UpgradeStub
	fakeReturns := fake.upgradeReturns
	fake.recordInvocation("Upgrade", []interface{}{arg1})
	fake.upgradeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeployment) UpgradeCallCount() int {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	return len(fake.upgradeArgsForCall)
}

func (fake *FakeDeployment) UpgradeCalls(stub func(kubernetes.Cluster) error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = stub
}

func (fake *FakeDeployment) UpgradeArgsForCall(i int) kubernetes.Cluster {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	argsForCall := fake.upgradeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDeployment) UpgradeReturns(result1 error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = nil
	fake.upgradeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) UpgradeReturnsOnCall(i int, result1 error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = nil
	if fake.upgradeReturnsOnCall == nil {
		fake.upgradeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.backupMutex.RLock()
	defer fake.backupMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deployMutex.RLock()
	defer fake.deployMutex.RUnlock()
	fake.describeMutex.RLock()
	defer fake.describeMutex.RUnlock()
	fake.getDomainMutex.RLock()
	defer fake.getDomainMutex.RUnlock()
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.neededUserInputMutex.RLock()
	defer fake.neededUserInputMutex.RUnlock()
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	fake.setDomainMutex.RLock()
	defer fake.setDomainMutex.RUnlock()
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDeployment) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kubernetes.Deployment = new(FakeDeployment)
